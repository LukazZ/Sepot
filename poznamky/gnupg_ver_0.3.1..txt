Help on module gnupg:

NAME
    gnupg - A wrapper for the 'gpg' command::

FILE
    c:\python27\lib\site-packages\gnupg.py

DESCRIPTION
    Portions of this module are derived from A.M. Kuchling's well-designed
    GPG.py, using Richard Jones' updated version 1.3, which can be found
    in the pycrypto CVS repository on Sourceforge:
    
    http://pycrypto.cvs.sourceforge.net/viewvc/pycrypto/gpg/GPG.py
    
    This module is *not* forward-compatible with amk's; some of the
    old interface has changed.  For instance, since I've added decrypt
    functionality, I elected to initialize with a 'gnupghome' argument
    instead of 'keyring', so that gpg can find both the public and secret
    keyrings.  I've also altered some of the returned objects in order for
    the caller to not have to know as much about the internals of the
    result classes.
    
    While the rest of ISconf is released under the GPL, I am releasing
    this single file under the same terms that A.M. Kuchling used for
    pycrypto.
    
    Steve Traugott, stevegt@terraluna.org
    Thu Jun 23 21:27:20 PDT 2005
    
    This version of the module has been modified from Steve Traugott's version
    (see http://trac.t7a.org/isconf/browser/trunk/lib/python/isconf/GPG.py) by
    Vinay Sajip to make use of the subprocess module (Steve's version uses os.fork()
    and so does not work on Windows). Renamed to gnupg.py to avoid confusion with
    the previous versions.
    
    Modifications Copyright (C) 2008-2012 Vinay Sajip. All rights reserved.
    
    A unittest harness (test_gnupg.py) has also been added.

CLASSES
    __builtin__.list(__builtin__.object)
        ListKeys
    __builtin__.object
        DeleteResult
        GPG
        GenKey
        ImportResult
        Sign
        Verify
            Crypt
    logging.Handler(logging.Filterer)
        NullHandler
    
    class Crypt(Verify)
     |  Handle status messages for --encrypt and --decrypt
     |  
     |  Method resolution order:
     |      Crypt
     |      Verify
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __init__(self, gpg)
     |  
     |  __nonzero__(self)
     |  
     |  __str__(self)
     |  
     |  handle_status(self, key, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from Verify:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from Verify:
     |  
     |  TRUST_FULLY = 3
     |  
     |  TRUST_LEVELS = {'TRUST_FULLY': 3, 'TRUST_MARGINAL': 2, 'TRUST_NEVER': ...
     |  
     |  TRUST_MARGINAL = 2
     |  
     |  TRUST_NEVER = 1
     |  
     |  TRUST_ULTIMATE = 4
     |  
     |  TRUST_UNDEFINED = 0
    
    class DeleteResult(__builtin__.object)
     |  Handle status messages for --delete-key and --delete-secret-key
     |  
     |  Methods defined here:
     |  
     |  __init__(self, gpg)
     |  
     |  __str__(self)
     |  
     |  handle_status(self, key, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  problem_reason = {'1': 'No such key', '2': 'Must delete secret key fir...
    
    class GPG(__builtin__.object)
     |  Methods defined here:
     |  
     |  __init__(self, gpgbinary='gpg', gnupghome=None, verbose=False, use_agent=False, keyring=None, options=None)
     |      Initialize a GPG process wrapper.  Options are:
     |      
     |      gpgbinary -- full pathname for GPG binary.
     |      
     |      gnupghome -- full pathname to where we can find the public and
     |      private keyrings.  Default is whatever gpg defaults to.
     |      keyring -- name of alternative keyring file to use. If specified,
     |      the default keyring is not used.
     |      options =-- a list of additional options to pass to the GPG binary.
     |  
     |  decrypt(self, message, **kwargs)
     |  
     |  decrypt_file(self, file, always_trust=False, passphrase=None, output=None)
     |  
     |  delete_keys(self, fingerprints, secret=False)
     |  
     |  encrypt(self, data, recipients, **kwargs)
     |      Encrypt the message contained in the string 'data'
     |      
     |      >>> import shutil
     |      >>> if os.path.exists("keys"):
     |      ...     shutil.rmtree("keys")
     |      >>> gpg = GPG(gnupghome="keys")
     |      >>> input = gpg.gen_key_input(passphrase='foo')
     |      >>> result = gpg.gen_key(input)
     |      >>> print1 = result.fingerprint
     |      >>> input = gpg.gen_key_input()
     |      >>> result = gpg.gen_key(input)
     |      >>> print2 = result.fingerprint
     |      >>> result = gpg.encrypt("hello",print2)
     |      >>> message = str(result)
     |      >>> assert message != 'hello'
     |      >>> result = gpg.decrypt(message)
     |      >>> assert result
     |      >>> str(result)
     |      'hello'
     |      >>> result = gpg.encrypt("hello again",print1)
     |      >>> message = str(result)
     |      >>> result = gpg.decrypt(message)
     |      >>> result.status == 'need passphrase'
     |      True
     |      >>> result = gpg.decrypt(message,passphrase='bar')
     |      >>> result.status in ('decryption failed', 'bad passphrase')
     |      True
     |      >>> assert not result
     |      >>> result = gpg.decrypt(message,passphrase='foo')
     |      >>> result.status == 'decryption ok'
     |      True
     |      >>> str(result)
     |      'hello again'
     |      >>> result = gpg.encrypt("signed hello",print2,sign=print1)
     |      >>> result.status == 'need passphrase'
     |      True
     |      >>> result = gpg.encrypt("signed hello",print2,sign=print1,passphrase='foo')
     |      >>> result.status == 'encryption ok'
     |      True
     |      >>> message = str(result)
     |      >>> result = gpg.decrypt(message)
     |      >>> result.status == 'decryption ok'
     |      True
     |      >>> assert result.fingerprint == print1
     |  
     |  encrypt_file(self, file, recipients, sign=None, always_trust=False, passphrase=None, armor=True, output=None, symmetric=False)
     |      Encrypt the message read from the file-like object 'file'
     |  
     |  export_keys(self, keyids, secret=False)
     |      export the indicated keys. 'keyid' is anything gpg accepts
     |  
     |  gen_key(self, input)
     |      Generate a key; you might use gen_key_input() to create the
     |      control input.
     |      
     |      >>> gpg = GPG(gnupghome="keys")
     |      >>> input = gpg.gen_key_input()
     |      >>> result = gpg.gen_key(input)
     |      >>> assert result
     |      >>> result = gpg.gen_key('foo')
     |      >>> assert not result
     |  
     |  gen_key_input(self, **kwargs)
     |      Generate --gen-key input per gpg doc/DETAILS
     |  
     |  import_keys(self, key_data)
     |      import the key_data into our keyring
     |      
     |      >>> import shutil
     |      >>> shutil.rmtree("keys")
     |      >>> gpg = GPG(gnupghome="keys")
     |      >>> input = gpg.gen_key_input()
     |      >>> result = gpg.gen_key(input)
     |      >>> print1 = result.fingerprint
     |      >>> result = gpg.gen_key(input)
     |      >>> print2 = result.fingerprint
     |      >>> pubkey1 = gpg.export_keys(print1)
     |      >>> seckey1 = gpg.export_keys(print1,secret=True)
     |      >>> seckeys = gpg.list_keys(secret=True)
     |      >>> pubkeys = gpg.list_keys()
     |      >>> assert print1 in seckeys.fingerprints
     |      >>> assert print1 in pubkeys.fingerprints
     |      >>> str(gpg.delete_keys(print1))
     |      'Must delete secret key first'
     |      >>> str(gpg.delete_keys(print1,secret=True))
     |      'ok'
     |      >>> str(gpg.delete_keys(print1))
     |      'ok'
     |      >>> str(gpg.delete_keys("nosuchkey"))
     |      'No such key'
     |      >>> seckeys = gpg.list_keys(secret=True)
     |      >>> pubkeys = gpg.list_keys()
     |      >>> assert not print1 in seckeys.fingerprints
     |      >>> assert not print1 in pubkeys.fingerprints
     |      >>> result = gpg.import_keys('foo')
     |      >>> assert not result
     |      >>> result = gpg.import_keys(pubkey1)
     |      >>> pubkeys = gpg.list_keys()
     |      >>> seckeys = gpg.list_keys(secret=True)
     |      >>> assert not print1 in seckeys.fingerprints
     |      >>> assert print1 in pubkeys.fingerprints
     |      >>> result = gpg.import_keys(seckey1)
     |      >>> assert result
     |      >>> seckeys = gpg.list_keys(secret=True)
     |      >>> pubkeys = gpg.list_keys()
     |      >>> assert print1 in seckeys.fingerprints
     |      >>> assert print1 in pubkeys.fingerprints
     |      >>> assert print2 in pubkeys.fingerprints
     |  
     |  list_keys(self, secret=False)
     |      list the keys currently in the keyring
     |      
     |      >>> import shutil
     |      >>> shutil.rmtree("keys")
     |      >>> gpg = GPG(gnupghome="keys")
     |      >>> input = gpg.gen_key_input()
     |      >>> result = gpg.gen_key(input)
     |      >>> print1 = result.fingerprint
     |      >>> result = gpg.gen_key(input)
     |      >>> print2 = result.fingerprint
     |      >>> pubkeys = gpg.list_keys()
     |      >>> assert print1 in pubkeys.fingerprints
     |      >>> assert print2 in pubkeys.fingerprints
     |  
     |  make_args(self, args, passphrase)
     |      Make a list of command line elements for GPG. The value of ``args``
     |      will be appended. The ``passphrase`` argument needs to be True if
     |      a passphrase will be sent to GPG, else False.
     |  
     |  recv_keys(self, keyserver, *keyids)
     |      Import a key from a keyserver
     |      
     |      >>> import shutil
     |      >>> shutil.rmtree("keys")
     |      >>> gpg = GPG(gnupghome="keys")
     |      >>> result = gpg.recv_keys('pgp.mit.edu', '3FF0DB166A7476EA')
     |      >>> assert result
     |  
     |  sign(self, message, **kwargs)
     |      sign message
     |  
     |  sign_file(self, file, keyid=None, passphrase=None, clearsign=True, detach=False, binary=False)
     |      sign file
     |  
     |  verify(self, data)
     |      Verify the signature on the contents of the string 'data'
     |      
     |      >>> gpg = GPG(gnupghome="keys")
     |      >>> input = gpg.gen_key_input(Passphrase='foo')
     |      >>> key = gpg.gen_key(input)
     |      >>> assert key
     |      >>> sig = gpg.sign('hello',keyid=key.fingerprint,passphrase='bar')
     |      >>> assert not sig
     |      >>> sig = gpg.sign('hello',keyid=key.fingerprint,passphrase='foo')
     |      >>> assert sig
     |      >>> verify = gpg.verify(sig.data)
     |      >>> assert verify
     |  
     |  verify_file(self, file, data_filename=None)
     |      Verify the signature on the contents of the file-like object 'file'
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  decode_errors = 'strict'
     |  
     |  result_map = {'crypt': <class 'gnupg.Crypt'>, 'delete': <class 'gnupg....
    
    class GenKey(__builtin__.object)
     |  Handle status messages for --gen-key
     |  
     |  Methods defined here:
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __init__(self, gpg)
     |  
     |  __nonzero__(self)
     |  
     |  __str__(self)
     |  
     |  handle_status(self, key, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class ImportResult(__builtin__.object)
     |  Handle status messages for --import
     |  
     |  Methods defined here:
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __init__(self, gpg)
     |  
     |  __nonzero__(self)
     |  
     |  handle_status(self, key, value)
     |  
     |  summary(self)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  counts = ['count', 'no_user_id', 'imported', 'imported_rsa', 'unchange...
     |  
     |  ok_reason = {'0': 'Not actually changed', '1': 'Entirely new key', '16...
     |  
     |  problem_reason = {'0': 'No specific reason given', '1': 'Invalid Certi...
    
    class ListKeys(__builtin__.list)
     |  Handle status messages for --list-keys.
     |  
     |  Handle pub and uid (relating the latter to the former).
     |  
     |  Don't care about (info from src/DETAILS):
     |  
     |  crt = X.509 certificate
     |  crs = X.509 certificate and private key available
     |  ssb = secret subkey (secondary key)
     |  uat = user attribute (same as user id except for field 10).
     |  sig = signature
     |  rev = revocation signature
     |  pkd = public key data (special field format, see below)
     |  grp = reserved for gpgsm
     |  rvk = revocation key
     |  
     |  Method resolution order:
     |      ListKeys
     |      __builtin__.list
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  __init__(self, gpg)
     |  
     |  fpr(self, args)
     |  
     |  handle_status(self, key, value)
     |  
     |  key(self, args)
     |  
     |  pub = key(self, args)
     |  
     |  sec = key(self, args)
     |  
     |  sub(self, args)
     |  
     |  uid(self, args)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from __builtin__.list:
     |  
     |  __add__(...)
     |      x.__add__(y) <==> x+y
     |  
     |  __contains__(...)
     |      x.__contains__(y) <==> y in x
     |  
     |  __delitem__(...)
     |      x.__delitem__(y) <==> del x[y]
     |  
     |  __delslice__(...)
     |      x.__delslice__(i, j) <==> del x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __eq__(...)
     |      x.__eq__(y) <==> x==y
     |  
     |  __ge__(...)
     |      x.__ge__(y) <==> x>=y
     |  
     |  __getattribute__(...)
     |      x.__getattribute__('name') <==> x.name
     |  
     |  __getitem__(...)
     |      x.__getitem__(y) <==> x[y]
     |  
     |  __getslice__(...)
     |      x.__getslice__(i, j) <==> x[i:j]
     |      
     |      Use of negative indices is not supported.
     |  
     |  __gt__(...)
     |      x.__gt__(y) <==> x>y
     |  
     |  __iadd__(...)
     |      x.__iadd__(y) <==> x+=y
     |  
     |  __imul__(...)
     |      x.__imul__(y) <==> x*=y
     |  
     |  __iter__(...)
     |      x.__iter__() <==> iter(x)
     |  
     |  __le__(...)
     |      x.__le__(y) <==> x<=y
     |  
     |  __len__(...)
     |      x.__len__() <==> len(x)
     |  
     |  __lt__(...)
     |      x.__lt__(y) <==> x<y
     |  
     |  __mul__(...)
     |      x.__mul__(n) <==> x*n
     |  
     |  __ne__(...)
     |      x.__ne__(y) <==> x!=y
     |  
     |  __repr__(...)
     |      x.__repr__() <==> repr(x)
     |  
     |  __reversed__(...)
     |      L.__reversed__() -- return a reverse iterator over the list
     |  
     |  __rmul__(...)
     |      x.__rmul__(n) <==> n*x
     |  
     |  __setitem__(...)
     |      x.__setitem__(i, y) <==> x[i]=y
     |  
     |  __setslice__(...)
     |      x.__setslice__(i, j, y) <==> x[i:j]=y
     |      
     |      Use  of negative indices is not supported.
     |  
     |  __sizeof__(...)
     |      L.__sizeof__() -- size of L in memory, in bytes
     |  
     |  append(...)
     |      L.append(object) -- append object to end
     |  
     |  count(...)
     |      L.count(value) -> integer -- return number of occurrences of value
     |  
     |  extend(...)
     |      L.extend(iterable) -- extend list by appending elements from the iterable
     |  
     |  index(...)
     |      L.index(value, [start, [stop]]) -> integer -- return first index of value.
     |      Raises ValueError if the value is not present.
     |  
     |  insert(...)
     |      L.insert(index, object) -- insert object before index
     |  
     |  pop(...)
     |      L.pop([index]) -> item -- remove and return item at index (default last).
     |      Raises IndexError if list is empty or index is out of range.
     |  
     |  remove(...)
     |      L.remove(value) -- remove first occurrence of value.
     |      Raises ValueError if the value is not present.
     |  
     |  reverse(...)
     |      L.reverse() -- reverse *IN PLACE*
     |  
     |  sort(...)
     |      L.sort(cmp=None, key=None, reverse=False) -- stable sort *IN PLACE*;
     |      cmp(x, y) -> -1, 0, 1
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes inherited from __builtin__.list:
     |  
     |  __hash__ = None
     |  
     |  __new__ = <built-in method __new__ of type object>
     |      T.__new__(S, ...) -> a new object with type S, a subtype of T
    
    class NullHandler(logging.Handler)
     |  Method resolution order:
     |      NullHandler
     |      logging.Handler
     |      logging.Filterer
     |      __builtin__.object
     |  
     |  Methods defined here:
     |  
     |  handle(self, record)
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from logging.Handler:
     |  
     |  __init__(self, level=0)
     |      Initializes the instance - basically setting the formatter to None
     |      and the filter list to empty.
     |  
     |  acquire(self)
     |      Acquire the I/O thread lock.
     |  
     |  close(self)
     |      Tidy up any resources used by the handler.
     |      
     |      This version removes the handler from an internal map of handlers,
     |      _handlers, which is used for handler lookup by name. Subclasses
     |      should ensure that this gets called from overridden close()
     |      methods.
     |  
     |  createLock(self)
     |      Acquire a thread lock for serializing access to the underlying I/O.
     |  
     |  emit(self, record)
     |      Do whatever it takes to actually log the specified logging record.
     |      
     |      This version is intended to be implemented by subclasses and so
     |      raises a NotImplementedError.
     |  
     |  flush(self)
     |      Ensure all logging output has been flushed.
     |      
     |      This version does nothing and is intended to be implemented by
     |      subclasses.
     |  
     |  format(self, record)
     |      Format the specified record.
     |      
     |      If a formatter is set, use it. Otherwise, use the default formatter
     |      for the module.
     |  
     |  get_name(self)
     |  
     |  handleError(self, record)
     |      Handle errors which occur during an emit() call.
     |      
     |      This method should be called from handlers when an exception is
     |      encountered during an emit() call. If raiseExceptions is false,
     |      exceptions get silently ignored. This is what is mostly wanted
     |      for a logging system - most users will not care about errors in
     |      the logging system, they are more interested in application errors.
     |      You could, however, replace this with a custom handler if you wish.
     |      The record which was being processed is passed in to this method.
     |  
     |  release(self)
     |      Release the I/O thread lock.
     |  
     |  setFormatter(self, fmt)
     |      Set the formatter for this handler.
     |  
     |  setLevel(self, level)
     |      Set the logging level of this handler.
     |  
     |  set_name(self, name)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from logging.Handler:
     |  
     |  name
     |  
     |  ----------------------------------------------------------------------
     |  Methods inherited from logging.Filterer:
     |  
     |  addFilter(self, filter)
     |      Add the specified filter to this handler.
     |  
     |  filter(self, record)
     |      Determine if a record is loggable by consulting all the filters.
     |      
     |      The default is to allow the record to be logged; any filter can veto
     |      this and the record is then dropped. Returns a zero value if a record
     |      is to be dropped, else non-zero.
     |  
     |  removeFilter(self, filter)
     |      Remove the specified filter from this handler.
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors inherited from logging.Filterer:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Sign(__builtin__.object)
     |  Handle status messages for --sign
     |  
     |  Methods defined here:
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __init__(self, gpg)
     |  
     |  __nonzero__(self)
     |  
     |  __str__(self)
     |  
     |  handle_status(self, key, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
    
    class Verify(__builtin__.object)
     |  Handle status messages for --verify
     |  
     |  Methods defined here:
     |  
     |  __bool__ = __nonzero__(self)
     |  
     |  __init__(self, gpg)
     |  
     |  __nonzero__(self)
     |  
     |  handle_status(self, key, value)
     |  
     |  ----------------------------------------------------------------------
     |  Data descriptors defined here:
     |  
     |  __dict__
     |      dictionary for instance variables (if defined)
     |  
     |  __weakref__
     |      list of weak references to the object (if defined)
     |  
     |  ----------------------------------------------------------------------
     |  Data and other attributes defined here:
     |  
     |  TRUST_FULLY = 3
     |  
     |  TRUST_LEVELS = {'TRUST_FULLY': 3, 'TRUST_MARGINAL': 2, 'TRUST_NEVER': ...
     |  
     |  TRUST_MARGINAL = 2
     |  
     |  TRUST_NEVER = 1
     |  
     |  TRUST_ULTIMATE = 4
     |  
     |  TRUST_UNDEFINED = 0

DATA
    PIPE = -1
    __author__ = 'Vinay Sajip'
    __date__ = '$01-Sep-2012 20:02:51$'
    __version__ = '0.3.1'
    logger = <logging.Logger object>

VERSION
    0.3.1

DATE
    $01-Sep-2012 20:02:51$

AUTHOR
    Vinay Sajip


